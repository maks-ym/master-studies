Task 6 (ambitious version)
Filesystem design

1. Goal of the excercise

  Implement in C language a set of programs providing a basic filesystem
  functionality and a script demonstrating its use. The programs should work
  in a Linux environment.

2. Program functions

  The filesystem should be organized as a single file (a "virtual disk"). The
  size of the file depends on the requested capacity and is constant. The
  programs (or program) provide the ability to create the file and perform
  read and write operations enabling the basic filesystem functionality -
  directory management, file allocation, filename handling, etc.

3. Task details

  The filesystem stored in the file should provide a single-level directory
  (no hierarchical directory/folder structure is required). The metadata
  regarding each file in the directory should include at least its name, size
  and location on disk. Unicode support in file names is not required - pure
  ASCII is sufficient. Still, characters like space or asterix should be
  allowed in filenames. Filename length may be limited, but not too small
  (e.g. 256 characters is acceptable, 16 is not). Filenames on the disk must
  be unique - attempts to create two files with the same name should be
  properly handled. The program or programs should support the following
  functions:

        - creating a virtual disk with specified size,

        - copying files from the system's disk to the virtual disk,

        - copying files from the virtual disk to the system's disk,

        - listing the directory of the virtual disk,

        - deleting files from the virtual disk,

        - removing a virtual disk,

        - displaying the current state of the disk, showing all
          blocks/sectors/sections/etc. including the information about the
          address, type, size, state (free/occupied), etc. Details depend on
          the structure of the filesystem and should be organized in a
          readable way.

  The program(s) should be implemented as console (shell) commands. A "master
  control program" with a GUI, menu or internal command line will not be
  accepted. Classic Unix commands (cp, rm, ls, etc.) should be considered as
  examples. Every program provided should support the option "--help" and
  provide sufficient usage information in response.

  Copy operations should allow copying multiple files. Explicit wildcard
  support is not required (for copying to the virtual disk this will be
  provided by the shell anyway, but obviously not in the other direction).

  The program(s) should control the amount of remaining space on the disk and
  react to operations that would exceed it.

  Support for opening files and accessing file fragments is not required.

  Concurrent access support is not required. Access is sequntial and
  exclusive.

  Demonstration should be automated and show both strong and weak points of
  the design regarding internal and external fragmentation.

  Proper parameter handling is required. E.g. a filename beginning with the
  "-" character is perfectly legal (the common approach is to use "--" as a
  parameter to signal that no more options are provided and the following
  parameters should be interpreted literally as e.g. filenames - look up
  "getopt" for a good tool to provide that and much more).

4. Demonstration and grading

  Proper abstraction is an important part of the design. The actual operations
  on the virtual disk should be a separate library. Failing to do this in a
  single-program implementation will result in 0.5 point penalty. For multiple
  programs this penalty is increased to 1 point, as it results in unnecessary
  code duplication.

  The demonstration should show the ability to work with both a small
  filesystem (e.g. 100kB) and a large one (e.g. 50MB). This should follow from
  intrinsic flexibility of the design - separate support for both cases is not
  allowed. Effects of fragmentation should be shown on the smaller filesystem,
  as they are easier to show then - for the large filesystem it is enough to
  show that it works properly.

  The main limit is the disk size, not file count. For block-based filesystems
  the filesystem should be able to handle being completely filled with
  single-block files. If blocks are not used, the directory capacity should be
  sufficient to allow the system to be completely filled with 4kB files.

  The filesystem should not be drastically inefficient. For example, the size
  of the file containing a filesystem with 100kB capacity may be 120kB
  (great!) or even 200kB (not so great), but if it exceeds 1MB, something is
  very wrong with the design.

  Before actual implementation, the design of the filesystem MUST be presented
  as a document (TXT, PDF, or even handwritten) and accepted. The mandatory
  elements include detailed structure of the file including form of a
  directory record. Tabular form showing individual fields with their data
  type, size and role is preferred.
